import os
import duckdb

""" Trusted to Exploitation
In the transition from the Trusted Zone to the Exploitation Zone, we reorganize the tables 
from the trusted database into a new database that focuses on key entities relevant to our analysis.
"""

def drop_all_tables(database_path):
    """
    Drop all the existing tables in a DuckDB database.
    """
    # Connect to the DuckDB database
    con = duckdb.connect(database=database_path)

    # Get all table names in the database
    tables = con.execute("SHOW TABLES").fetchall()

    # Drop each table
    for (table_name,) in tables:  # each result is a tuple, so unpack it
        con.execute(f"DROP TABLE {table_name}")

    # Close the connection
    con.close()

def trusted2exploit(duckdb_file_path, exploit_dir):
    """
    Creates a new exploitation DuckDB database with selected tables from the trusted database.
    """

    # Connect to the trusted database
    con_trusted = duckdb.connect(database=duckdb_file_path, read_only=True)

    # Load tables from the trusted database
    ticketmaster_df = con_trusted.execute("SELECT * FROM ticketmaster").df()
    spotify_df = con_trusted.execute("SELECT * FROM spotify").df()

    # Close connection
    con_trusted.close()

    # Create the exploitation directory if it doesn't exist
    if not os.path.exists(exploit_dir):
        os.makedirs(exploit_dir)

    # Path for the new exploitation database
    exploit_duckdb_path = os.path.join(exploit_dir, 'exploitation.duckdb')
    drop_all_tables(exploit_duckdb_path) # If tables are already created, drop them

    # Connect to the new exploitation database
    con_exploit = duckdb.connect(database=exploit_duckdb_path)

    # Create new tables in the exploitation database from dataframes
    con_exploit.execute("CREATE TABLE artists AS SELECT artist, genres, source_date FROM spotify_df WHERE source_date = (SELECT MAX(source_date) FROM spotify_df)")
    con_exploit.execute("CREATE TABLE artists_stats AS SELECT artist, popularity, followers, source_date FROM spotify_df")
    con_exploit.execute("CREATE TABLE events AS SELECT DISTINCT artist, name, date, time, venue, min_price_EUR, max_price_EUR FROM ticketmaster_df") # ensure no duplicates
    con_exploit.execute("CREATE TABLE venues AS SELECT venue, city, country FROM ticketmaster_df GROUP BY venue, city, country") # ensure no duplicates

    # Close the connection to the exploitation database
    con_exploit.close()
    
    print(f"DuckDB exploitation database successfully saved in: {exploit_duckdb_path}")

##### Pre-calculated tables addition

def new_structure_artist_stats(con):
  """
  Create a new format for the artists stats table, consisting in a
  pivoted dataframe with artists as rows and separate columns for popularity
  and followers for each source date, i.e. version date.
  """
  artists_stats = con.execute("SELECT * FROM artists_stats").df()
  df_pivoted = artists_stats.pivot(index='artist', columns='source_date', values=['popularity', 'followers'])
  df_pivoted.columns = [f"{metric}_{date}" for metric, date in df_pivoted.columns]
  df_pivoted = df_pivoted.reset_index()
  df_pivoted
  return df_pivoted

def avg_metrics_per_artist(con):
  """
  Calculate the average popularity and followers of each artist.
  """
  artists_stats = con.execute("SELECT * FROM artists_stats").df()
  avg_metrics = artists_stats.groupby('artist').agg(
        avg_followers=('followers', 'mean'),
        avg_popularity=('popularity', 'mean')
    ).reset_index()
  return avg_metrics

def genres_by_popularity(con):
  """
  Calculate the average popularity of each music genre from the artists and artists_stats tables.
  """
  genres = con.execute("SELECT * FROM artists").df()
  artists_stats = con.execute("SELECT * FROM artists_stats").df()
  df = con.execute("SELECT stats.artist, genres, popularity FROM artists_stats stats, genres g WHERE stats.artist = g.artist").df()
  df_exploded = df.explode('genres')
  # Calculate average popularity per genre
  avg_popularity = df_exploded.groupby('genres')['popularity'].mean().reset_index()
  avg_popularity.columns =  ['genres', 'avg_popularity']
  return avg_popularity

def events_counts(con):
  """
  Calculate the average popularity of each music genre from the artists and artists_stats tables.
  """
  events = con.execute("SELECT * FROM events").df()
  events_counts_df = con.execute("SELECT artist, COUNT(*) AS event_count FROM events GROUP BY artist ORDER BY event_count DESC").df()
  return events_counts_df

def avg_prices(con):
  """
  Calculate the average popularity of each music genre from the artists and artists_stats tables.
  """
  events = con.execute("SELECT * FROM events").df()
  avg_prices_df = con.execute("SELECT artist, AVG(min_price_EUR) AS avg_min_price, AVG(max_price_EUR) AS avg_max_price FROM events GROUP BY artist").df()
  return avg_prices_df

"""
Save the pre-calculated tables in the database.
"""

def add_tables_to_duckdb(duckdb_file):
    """
    Adds pre-calculated tables into the database.
    """
    con = duckdb.connect(database=duckdb_file)

    artists_stats = new_structure_artist_stats(con)
    avg_metrics_artists = avg_metrics_per_artist(con)
    genre_by_popularity = genres_by_popularity(con)
    event_count = events_counts(con)
    avg_price = avg_prices(con)

    tables = {
        "avg_metrics_artists": avg_metrics_artists,
        "genre_by_popularity": genre_by_popularity,
        "event_count": event_count,
        "avg_price": avg_price
    }

    # Loop through each dataframe and add it to the database
    for table_name, df in tables.items():
        con.execute(f"DROP TABLE IF EXISTS {table_name}")  # Drop table if it already exists
        con.execute(f"CREATE TABLE {table_name} AS SELECT * FROM df")

    # Close the connection
    con.close()
    print(f"Pre-computed tables successfully added in: {duckdb_file}")

if __name__ == "__main__":
    duckdb_file_path = input("Path to DuckDB file (input): ")
    exploit_dir = input("Exploitation directory path (output): ")
    trusted2exploit(duckdb_file_path, exploit_dir)
    exploit_duckdb_path = os.path.join(exploit_dir, 'exploitation.duckdb')
    add_tables_to_duckdb(exploit_duckdb_path)